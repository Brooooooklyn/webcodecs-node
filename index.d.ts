/* auto-generated by NAPI-RS */
/* eslint-disable */
/**
 * AudioData - represents uncompressed audio data
 *
 * This is a WebCodecs-compliant AudioData implementation backed by FFmpeg.
 */
export declare class AudioData {
  /**
   * Create a new AudioData (W3C WebCodecs spec)
   * Per spec, the constructor takes a single init object containing all parameters including data
   */
  constructor(init: AudioDataInit)
  /** Get sample format */
  get format(): AudioSampleFormat | null
  /** Get sample rate in Hz */
  get sampleRate(): number
  /** Get number of frames (samples per channel) */
  get numberOfFrames(): number
  /** Get number of channels */
  get numberOfChannels(): number
  /** Get duration in microseconds */
  get duration(): number
  /** Get timestamp in microseconds */
  get timestamp(): number
  /** Get whether this AudioData has been closed (W3C WebCodecs spec) */
  get closed(): boolean
  /**
   * Get the buffer size required for copyTo (W3C WebCodecs spec)
   * Note: options is REQUIRED per spec
   */
  allocationSize(options: AudioDataCopyToOptions): number
  /**
   * Copy audio data to a buffer (W3C WebCodecs spec)
   * Note: Per spec, this is SYNCHRONOUS and returns undefined
   */
  copyTo(destination: Uint8Array, options: AudioDataCopyToOptions): void
  /** Create a copy of this AudioData */
  clone(): AudioData
  /** Close and release resources */
  close(): void
}

/**
 * AudioDecoder - WebCodecs-compliant audio decoder
 *
 * Decodes EncodedAudioChunk objects into AudioData objects using FFmpeg.
 *
 * Per the WebCodecs spec, the constructor takes an init dictionary with callbacks.
 *
 * Example:
 * ```javascript
 * const decoder = new AudioDecoder({
 *   output: (data) => { console.log('decoded audio', data); },
 *   error: (e) => { console.error('error', e); }
 * });
 *
 * decoder.configure({
 *   codec: 'opus',
 *   sampleRate: 48000,
 *   numberOfChannels: 2
 * });
 *
 * decoder.decode(chunk);
 * await decoder.flush();
 * ```
 */
export declare class AudioDecoder {
  /**
   * Create a new AudioDecoder with init dictionary (per WebCodecs spec)
   *
   * @param init - Init dictionary containing output and error callbacks
   */
  constructor(init: { output: (data: AudioData) => void, error: (error: Error) => void })
  /** Get decoder state */
  get state(): CodecState
  /** Get number of pending decode operations (per WebCodecs spec) */
  get decodeQueueSize(): number
  /**
   * Set the dequeue event handler (per WebCodecs spec)
   *
   * The dequeue event fires when decodeQueueSize decreases,
   * allowing backpressure management.
   */
  set ondequeue(callback?: (() => unknown) | undefined | null)
  /** Get the dequeue event handler (per WebCodecs spec) */
  get ondequeue(): (() => unknown) | null
  /** Configure the decoder */
  configure(config: AudioDecoderConfig): void
  /** Decode an encoded audio chunk */
  decode(chunk: EncodedAudioChunk): void
  /**
   * Flush the decoder
   * Returns a Promise that resolves when flushing is complete
   */
  flush(): Promise<void>
  /** Reset the decoder */
  reset(): void
  /** Close the decoder */
  close(): void
  /**
   * Check if a configuration is supported
   * Returns a Promise that resolves with support information
   */
  static isConfigSupported(config: AudioDecoderConfig): Promise<AudioDecoderSupport>
}

/**
 * AudioEncoder - WebCodecs-compliant audio encoder
 *
 * Encodes AudioData objects into EncodedAudioChunk objects using FFmpeg.
 *
 * Per the WebCodecs spec, the constructor takes an init dictionary with callbacks.
 *
 * Example:
 * ```javascript
 * const encoder = new AudioEncoder({
 *   output: (chunk, metadata) => { console.log('encoded chunk', chunk); },
 *   error: (e) => { console.error('error', e); }
 * });
 *
 * encoder.configure({
 *   codec: 'opus',
 *   sampleRate: 48000,
 *   numberOfChannels: 2
 * });
 *
 * encoder.encode(audioData);
 * await encoder.flush();
 * ```
 */
export declare class AudioEncoder {
  /**
   * Create a new AudioEncoder with init dictionary (per WebCodecs spec)
   *
   * @param init - Init dictionary containing output and error callbacks
   */
  constructor(init: { output: (chunk: EncodedAudioChunk, metadata?: EncodedAudioChunkMetadata) => void, error: (error: Error) => void })
  /** Get encoder state */
  get state(): CodecState
  /** Get number of pending encode operations (per WebCodecs spec) */
  get encodeQueueSize(): number
  /**
   * Set the dequeue event handler (per WebCodecs spec)
   *
   * The dequeue event fires when encodeQueueSize decreases,
   * allowing backpressure management.
   */
  set ondequeue(callback?: (() => unknown) | undefined | null)
  /** Get the dequeue event handler (per WebCodecs spec) */
  get ondequeue(): (() => unknown) | null
  /** Configure the encoder */
  configure(config: AudioEncoderConfig): void
  /** Encode audio data */
  encode(data: AudioData): void
  /**
   * Flush the encoder
   * Returns a Promise that resolves when flushing is complete
   */
  flush(): Promise<void>
  /** Reset the encoder */
  reset(): void
  /** Close the encoder */
  close(): void
  /**
   * Check if a configuration is supported
   * Returns a Promise that resolves with support information
   */
  static isConfigSupported(config: AudioEncoderConfig): Promise<AudioEncoderSupport>
}

/**
 * DOMRectReadOnly - W3C WebCodecs spec compliant rect class
 * Used for codedRect and visibleRect properties
 */
export declare class DOMRectReadOnly {
  /** Create a new DOMRectReadOnly */
  constructor(x?: number | undefined | null, y?: number | undefined | null, width?: number | undefined | null, height?: number | undefined | null)
  /** X coordinate */
  get x(): number
  /** Y coordinate */
  get y(): number
  /** Width */
  get width(): number
  /** Height */
  get height(): number
  /** Top edge (same as y) */
  get top(): number
  /** Right edge (x + width) */
  get right(): number
  /** Bottom edge (y + height) */
  get bottom(): number
  /** Left edge (same as x) */
  get left(): number
  /** Convert to JSON (W3C spec uses toJSON) */
  toJSON(): DOMRectInit
}

/**
 * EncodedAudioChunk - represents encoded audio data
 *
 * This is a WebCodecs-compliant EncodedAudioChunk implementation.
 */
export declare class EncodedAudioChunk {
  /** Create a new EncodedAudioChunk */
  constructor(init: EncodedAudioChunkInit)
  /** Get the chunk type */
  get type(): EncodedAudioChunkType
  /** Get the timestamp in microseconds */
  get timestamp(): number
  /** Get the duration in microseconds */
  get duration(): number | null
  /** Get the byte length of the encoded data */
  get byteLength(): number
  /** Copy the encoded data to a Uint8Array */
  copyTo(destination: Uint8Array): void
}

/**
 * EncodedVideoChunk - represents encoded video data
 *
 * This is a WebCodecs-compliant EncodedVideoChunk implementation.
 */
export declare class EncodedVideoChunk {
  /** Create a new EncodedVideoChunk */
  constructor(init: EncodedVideoChunkInit)
  /** Get the chunk type */
  get type(): EncodedVideoChunkType
  /** Get the timestamp in microseconds */
  get timestamp(): number
  /** Get the duration in microseconds */
  get duration(): number | null
  /** Get the byte length of the encoded data */
  get byteLength(): number
  /** Copy the encoded data to a Uint8Array */
  copyTo(destination: Uint8Array): void
}

/**
 * ImageDecoder - WebCodecs-compliant image decoder
 *
 * Decodes image data (JPEG, PNG, WebP, GIF, BMP) into VideoFrame objects.
 *
 * Example:
 * ```javascript
 * const decoder = new ImageDecoder({
 *   data: imageBytes,
 *   type: 'image/png'
 * });
 *
 * const result = await decoder.decode();
 * const frame = result.image;
 * ```
 */
export declare class ImageDecoder {
  /**
   * Create a new ImageDecoder
   * Supports both Uint8Array and ReadableStream as data source per W3C spec
   */
  constructor(init: ImageDecoderInit)
  /** Whether the data is fully buffered */
  get complete(): boolean
  /**
   * Promise that resolves when data is fully loaded (per WebCodecs spec)
   * Returns a new promise chained from the stored promise (allows multiple accesses)
   */
  get completed(): Promise<undefined>
  /** Get the MIME type */
  get type(): string
  /** Get the track list */
  get tracks(): ImageTrackList
  /** Decode the image (or a specific frame) */
  decode(this: this, options?: ImageDecodeOptions | undefined | null): Promise<ImageDecodeResult>
  /**
   * Reset the decoder
   * Clears cached frames - next decode() will re-decode from stored data
   */
  reset(): void
  /** Close the decoder */
  close(): void
  /** Whether this ImageDecoder has been closed (W3C WebCodecs spec) */
  get closed(): boolean
  /** Check if a MIME type is supported */
  static isTypeSupported(mimeType: string): Promise<boolean>
}

/**
 * Image decode result
 * Note: W3C spec defines this as a dictionary, but NAPI-RS doesn't support
 * class instances in objects, so we use a class with the same properties.
 */
export declare class ImageDecodeResult {
  /** Get the decoded image */
  get image(): VideoFrame
  /** Get whether the decode is complete */
  get complete(): boolean
}

/** Image track information (W3C spec - class with writable selected property) */
export declare class ImageTrack {
  /** Whether this track is animated */
  get animated(): boolean
  /** Number of frames in this track */
  get frameCount(): number
  /** Number of times the animation repeats (Infinity for infinite) */
  get repetitionCount(): number
  /** Whether this track is currently selected (W3C spec - writable) */
  get selected(): boolean
  /**
   * Set whether this track is selected (W3C spec - writable)
   * Setting to true deselects all other tracks
   */
  set selected(value: boolean)
}

/** Image track list (W3C spec) */
export declare class ImageTrackList {
  /** Get the number of tracks */
  get length(): number
  /** Get the currently selected track (if any) */
  get selectedTrack(): ImageTrack | null
  /** Get the selected track index (W3C spec: returns -1 if no track selected) */
  get selectedIndex(): number
  /** Promise that resolves when track metadata is available (W3C spec) */
  get ready(): Promise<void>
  /** Get track at specified index (W3C spec) */
  item(index: number): ImageTrack | null
}

/** Video color space parameters (WebCodecs spec) - as a class per spec */
export declare class VideoColorSpace {
  /** Create a new VideoColorSpace */
  constructor(init?: VideoColorSpaceInit | undefined | null)
  /** Get color primaries */
  get primaries(): string | null
  /** Get transfer characteristics */
  get transfer(): string | null
  /** Get matrix coefficients */
  get matrix(): string | null
  /** Get full range flag */
  get fullRange(): boolean | null
  /** Convert to JSON-compatible object (W3C spec uses toJSON) */
  toJSON(): VideoColorSpaceInit
}

/**
 * VideoDecoder - WebCodecs-compliant video decoder
 *
 * Decodes EncodedVideoChunk objects into VideoFrame objects using FFmpeg.
 *
 * Per the WebCodecs spec, the constructor takes an init dictionary with callbacks.
 *
 * Example:
 * ```javascript
 * const decoder = new VideoDecoder({
 *   output: (frame) => { console.log('decoded frame', frame); },
 *   error: (e) => { console.error('error', e); }
 * });
 *
 * decoder.configure({
 *   codec: 'avc1.42001E'
 * });
 *
 * decoder.decode(chunk);
 * await decoder.flush();
 * ```
 */
export declare class VideoDecoder {
  /**
   * Create a new VideoDecoder with init dictionary (per WebCodecs spec)
   *
   * @param init - Init dictionary containing output and error callbacks
   */
  constructor(init: { output: (frame: VideoFrame) => void, error: (error: Error) => void })
  /** Get decoder state */
  get state(): CodecState
  /** Get number of pending decode operations (per WebCodecs spec) */
  get decodeQueueSize(): number
  /**
   * Set the dequeue event handler (per WebCodecs spec)
   *
   * The dequeue event fires when decodeQueueSize decreases,
   * allowing backpressure management.
   */
  set ondequeue(callback?: (() => unknown) | undefined | null)
  /** Get the dequeue event handler (per WebCodecs spec) */
  get ondequeue(): (() => unknown) | null
  /** Configure the decoder */
  configure(config: VideoDecoderConfig): void
  /** Decode an encoded video chunk */
  decode(chunk: EncodedVideoChunk): void
  /**
   * Flush the decoder
   * Returns a Promise that resolves when flushing is complete
   */
  flush(): Promise<void>
  /** Reset the decoder */
  reset(): void
  /** Close the decoder */
  close(): void
  /**
   * Check if a configuration is supported
   * Returns a Promise that resolves with support information
   */
  static isConfigSupported(config: VideoDecoderConfig): Promise<VideoDecoderSupport>
}

/**
 * VideoEncoder - WebCodecs-compliant video encoder
 *
 * Encodes VideoFrame objects into EncodedVideoChunk objects using FFmpeg.
 *
 * Per the WebCodecs spec, the constructor takes an init dictionary with callbacks.
 *
 * Example:
 * ```javascript
 * const encoder = new VideoEncoder({
 *   output: (chunk, metadata) => { console.log('encoded chunk', chunk); },
 *   error: (e) => { console.error('error', e); }
 * });
 *
 * encoder.configure({
 *   codec: 'avc1.42001E',
 *   width: 1920,
 *   height: 1080,
 *   bitrate: 5_000_000
 * });
 *
 * encoder.encode(frame);
 * await encoder.flush();
 * ```
 */
export declare class VideoEncoder {
  /**
   * Create a new VideoEncoder with init dictionary (per WebCodecs spec)
   *
   * @param init - Init dictionary containing output and error callbacks
   */
  constructor(init: { output: (chunk: EncodedVideoChunk, metadata?: EncodedVideoChunkMetadata) => void, error: (error: Error) => void })
  /** Get encoder state */
  get state(): CodecState
  /** Get number of pending encode operations (per WebCodecs spec) */
  get encodeQueueSize(): number
  /**
   * Set the dequeue event handler (per WebCodecs spec)
   *
   * The dequeue event fires when encodeQueueSize decreases,
   * allowing backpressure management.
   */
  set ondequeue(callback?: (() => unknown) | undefined | null)
  /** Get the dequeue event handler (per WebCodecs spec) */
  get ondequeue(): (() => unknown) | null
  /** Configure the encoder */
  configure(config: VideoEncoderConfig): void
  /** Encode a frame */
  encode(frame: VideoFrame, options?: VideoEncoderEncodeOptions | undefined | null): void
  /**
   * Flush the encoder
   * Returns a Promise that resolves when flushing is complete
   */
  flush(): Promise<void>
  /** Reset the encoder */
  reset(): void
  /** Close the encoder */
  close(): void
  /**
   * Check if a configuration is supported
   * Returns a Promise that resolves with support information
   */
  static isConfigSupported(config: VideoEncoderConfig): Promise<VideoEncoderSupport>
}

/**
 * VideoFrame - represents a frame of video
 *
 * This is a WebCodecs-compliant VideoFrame implementation backed by FFmpeg.
 */
export declare class VideoFrame {
  /**
   * Create a new VideoFrame from raw buffer data (BufferSource per spec)
   *
   * This is the VideoFrameBufferInit constructor form.
   * Use `fromVideoFrame()` to create from another VideoFrame.
   */
  constructor(data: Uint8Array, init: VideoFrameBufferInit)
  /**
   * Create a new VideoFrame from another VideoFrame (image source constructor per spec)
   *
   * This clones the source VideoFrame and applies any overrides from init.
   * Per W3C spec, this is equivalent to `new VideoFrame(videoFrame, init)`.
   */
  static fromVideoFrame(source: VideoFrame, init?: VideoFrameInit | undefined | null): VideoFrame
  /** Get the pixel format */
  get format(): VideoPixelFormat | null
  /** Get the coded width in pixels */
  get codedWidth(): number
  /** Get the coded height in pixels */
  get codedHeight(): number
  /** Get the display width in pixels */
  get displayWidth(): number
  /** Get the display height in pixels */
  get displayHeight(): number
  /**
   * Get the coded rect (the region containing valid pixel data)
   * Returns DOMRectReadOnly per W3C WebCodecs spec
   * Throws InvalidStateError if the VideoFrame is closed
   */
  get codedRect(): DOMRectReadOnly
  /**
   * Get the visible rect (the region of coded data that should be displayed)
   * Returns DOMRectReadOnly per W3C WebCodecs spec
   * Throws InvalidStateError if the VideoFrame is closed
   */
  get visibleRect(): DOMRectReadOnly
  /** Get the presentation timestamp in microseconds */
  get timestamp(): number
  /** Get the duration in microseconds */
  get duration(): number | null
  /** Get the color space parameters */
  get colorSpace(): VideoColorSpace
  /** Get whether this VideoFrame has been closed (W3C WebCodecs spec) */
  get closed(): boolean
  /** Get the rotation in degrees clockwise (0, 90, 180, 270) - W3C WebCodecs spec */
  get rotation(): number
  /** Get whether horizontal flip is applied - W3C WebCodecs spec */
  get flip(): boolean
  /**
   * Get the metadata associated with this VideoFrame - W3C WebCodecs spec
   * Currently returns an empty metadata object as members are defined in the registry
   */
  metadata(): VideoFrameMetadata
  /** Calculate the allocation size needed for copyTo */
  allocationSize(options?: VideoFrameCopyToOptions | undefined | null): number
  /**
   * Copy frame data to a Uint8Array
   *
   * Returns a Promise that resolves with an array of PlaneLayout objects.
   * Options can specify target format. The rect parameter is not yet implemented.
   */
  copyTo(destination: Uint8Array, options?: VideoFrameCopyToOptions | undefined | null): Promise<Array<PlaneLayout>>
  /** Clone this VideoFrame */
  clone(): VideoFrame
  /** Close and release resources */
  close(): void
}

/** Alpha channel handling option (W3C WebCodecs spec) */
export type AlphaOption = /** Keep alpha channel if present */
'keep'|
/** Discard alpha channel */
'discard';

/** Options for copyTo operation */
export interface AudioDataCopyToOptions {
  /** The index of the audio plane to copy */
  planeIndex: number
  /** The offset in frames to start copying from (optional) */
  frameOffset?: number
  /** The number of frames to copy (optional, defaults to all remaining) */
  frameCount?: number
  /** Target format for conversion (optional) */
  format?: AudioSampleFormat
}

/**
 * Options for creating an AudioData (W3C WebCodecs spec)
 * Note: Per spec, data is included in the init object
 */
export interface AudioDataInit {
  /** Sample format (required) */
  format: AudioSampleFormat
  /** Sample rate in Hz (required) */
  sampleRate: number
  /** Number of frames (samples per channel) (required) */
  numberOfFrames: number
  /** Number of channels (required) */
  numberOfChannels: number
  /** Timestamp in microseconds (required) */
  timestamp: number
  /** Raw audio sample data (required) - BufferSource per spec */
  data: Uint8Array
  /** ArrayBuffers to transfer (W3C spec - ignored in Node.js, we always copy) */
  transfer?: ArrayBuffer[]
}

/** Audio decoder configuration (WebCodecs spec) */
export interface AudioDecoderConfig {
  /** Codec string (e.g., "mp4a.40.2" for AAC-LC, "opus") */
  codec: string
  /** Sample rate in Hz (required per spec) */
  sampleRate: number
  /** Number of channels (required per spec) */
  numberOfChannels: number
  /** Codec-specific description data (e.g., AudioSpecificConfig for AAC) - BufferSource per spec */
  description?: Uint8Array
}

/** Decoder configuration output (for passing to decoder) */
export interface AudioDecoderConfigOutput {
  /** Codec string */
  codec: string
  /** Sample rate */
  sampleRate?: number
  /** Number of channels */
  numberOfChannels?: number
  /** Codec description (e.g., AudioSpecificConfig for AAC) - Uint8Array per spec */
  description?: Uint8Array
}

/** Audio decoder support information */
export interface AudioDecoderSupport {
  /** Whether the configuration is supported */
  supported: boolean
  /** The configuration that was tested */
  config: AudioDecoderConfig
}

/**
 * Audio encoder configuration (WebCodecs spec)
 * Note: Per W3C spec, codec-specific options are not supported at this level.
 * Codec behavior is controlled through the codec string itself.
 */
export interface AudioEncoderConfig {
  /** Codec string (e.g., "mp4a.40.2" for AAC-LC, "opus") */
  codec: string
  /** Sample rate in Hz (required per spec) */
  sampleRate: number
  /** Number of channels (required per spec) */
  numberOfChannels: number
  /** Target bitrate in bits per second */
  bitrate?: number
  /** Bitrate mode (W3C spec enum) */
  bitrateMode?: BitrateMode
}

/** Encode options for audio */
export interface AudioEncoderEncodeOptions {

}

/** Audio encoder support information */
export interface AudioEncoderSupport {
  /** Whether the configuration is supported */
  supported: boolean
  /** The configuration that was tested */
  config: AudioEncoderConfig
}

/** Audio sample format (WebCodecs spec) */
export type AudioSampleFormat = /** Unsigned 8-bit integer samples| interleaved */
'u8'|
/** Signed 16-bit integer samples| interleaved */
's16'|
/** Signed 32-bit integer samples| interleaved */
's32'|
/** 32-bit float samples| interleaved */
'f32'|
/** Unsigned 8-bit integer samples| planar */
'u8-planar'|
/** Signed 16-bit integer samples| planar */
's16-planar'|
/** Signed 32-bit integer samples| planar */
's32-planar'|
/** 32-bit float samples| planar */
'f32-planar';

/** Bitrate mode for audio encoding (W3C WebCodecs spec) */
export type BitrateMode = /** Variable bitrate (default) */
'variable'|
/** Constant bitrate */
'constant';

/** Encoder state per WebCodecs spec */
export type CodecState = /** Encoder not configured */
'unconfigured'|
/** Encoder configured and ready */
'configured'|
/** Encoder closed */
'closed';

/** ColorSpaceConversion for ImageDecoder (W3C WebCodecs spec) */
export type ColorSpaceConversion = /** Apply default color space conversion (spec default) */
'Default'|
/** No color space conversion */
'None';

/** DOMRectInit for specifying regions */
export interface DOMRectInit {
  x?: number
  y?: number
  width?: number
  height?: number
}

/** Options for creating an EncodedAudioChunk */
export interface EncodedAudioChunkInit {
  /** Chunk type (key or delta) */
  type: EncodedAudioChunkType
  /** Timestamp in microseconds */
  timestamp: number
  /**
   * Duration in microseconds (optional)
   * Note: W3C spec uses unsigned long long, but JS number can represent up to 2^53 safely
   */
  duration?: number
  /** Encoded data (BufferSource per spec) */
  data: Uint8Array
  /** ArrayBuffers to transfer (W3C spec - ignored in Node.js, we always copy) */
  transfer?: ArrayBuffer[]
}

/** Output callback metadata for audio */
export interface EncodedAudioChunkMetadata {
  /** Decoder configuration for this chunk */
  decoderConfig?: AudioDecoderConfigOutput
}

/** Type of encoded audio chunk */
export type EncodedAudioChunkType = /** Key chunk - can be decoded independently */
'key'|
/** Delta chunk - depends on previous chunks */
'delta';

/** Options for creating an EncodedVideoChunk */
export interface EncodedVideoChunkInit {
  /** Chunk type (key or delta) */
  type: EncodedVideoChunkType
  /** Timestamp in microseconds */
  timestamp: number
  /**
   * Duration in microseconds (optional)
   * Note: W3C spec uses unsigned long long, but JS number can represent up to 2^53 safely
   */
  duration?: number
  /** Encoded data (BufferSource per spec) */
  data: Uint8Array
  /** ArrayBuffers to transfer (W3C spec - ignored in Node.js, we always copy) */
  transfer?: ArrayBuffer[]
}

/** Output callback metadata per WebCodecs spec */
export interface EncodedVideoChunkMetadata {
  /** Decoder configuration for this chunk (only present for keyframes) */
  decoderConfig?: VideoDecoderConfigOutput
}

/** Type of encoded video chunk */
export type EncodedVideoChunkType = /** Keyframe - can be decoded independently */
'key'|
/** Delta frame - depends on previous frames */
'delta';

/** Get available hardware accelerators (only those that can be used) */
export declare function getAvailableHardwareAccelerators(): Array<string>

/** Get list of all known hardware accelerators and their availability */
export declare function getHardwareAccelerators(): Array<HardwareAccelerator>

/** Get the preferred hardware accelerator for the current platform */
export declare function getPreferredHardwareAccelerator(): string | null

/** Hardware acceleration preference (W3C WebCodecs spec) */
export type HardwareAcceleration = /** No preference - may use hardware or software */
'no-preference'|
/** Prefer hardware acceleration */
'prefer-hardware'|
/** Prefer software implementation */
'prefer-software';

/** Hardware accelerator information */
export interface HardwareAccelerator {
  /** Internal name (e.g., "videotoolbox", "cuda", "vaapi") */
  name: string
  /** Human-readable description */
  description: string
  /** Whether this accelerator is available on this system */
  available: boolean
}

/** Image decode options */
export interface ImageDecodeOptions {
  /** Frame index to decode (for animated images) */
  frameIndex?: number
  /** Whether to only decode complete frames */
  completeFramesOnly?: boolean
}

/** Check if a specific hardware accelerator is available */
export declare function isHardwareAcceleratorAvailable(name: string): boolean

/** Latency mode for video encoding (W3C WebCodecs spec) */
export type LatencyMode = /** Optimize for quality (default) */
'quality'|
/** Optimize for low latency */
'realtime';

/** Layout information for a single plane per WebCodecs spec */
export interface PlaneLayout {
  /** Byte offset from the start of the buffer to the start of the plane */
  offset: number
  /** Number of bytes per row (stride) */
  stride: number
}

/** VideoColorSpaceInit for constructing VideoColorSpace */
export interface VideoColorSpaceInit {
  /** Color primaries (e.g., "bt709", "bt2020") */
  primaries?: string
  /** Transfer function (e.g., "bt709", "srgb", "pq", "hlg") */
  transfer?: string
  /** Matrix coefficients (e.g., "bt709", "bt2020-ncl") */
  matrix?: string
  /** Full range flag */
  fullRange?: boolean
}

/** Video decoder configuration (WebCodecs spec) */
export interface VideoDecoderConfig {
  /** Codec string (e.g., "avc1.42001E", "vp8", "vp09.00.10.08") */
  codec: string
  /** Coded width in pixels (optional for some codecs) */
  codedWidth?: number
  /** Coded height in pixels (optional for some codecs) */
  codedHeight?: number
  /** Display aspect width */
  displayAspectWidth?: number
  /** Display aspect height */
  displayAspectHeight?: number
  /** Color space parameters (uses init object for compatibility) */
  colorSpace?: VideoColorSpaceInit
  /** Hardware acceleration preference (W3C spec enum) */
  hardwareAcceleration?: HardwareAcceleration
  /** Optimize for latency (W3C spec) */
  optimizeForLatency?: boolean
  /** Codec-specific description data (e.g., avcC for H.264) - BufferSource per spec */
  description?: Uint8Array
}

/** Decoder configuration output (for passing to decoder) */
export interface VideoDecoderConfigOutput {
  /** Codec string */
  codec: string
  /** Coded width */
  codedWidth?: number
  /** Coded height */
  codedHeight?: number
  /** Codec description (e.g., avcC for H.264) - Uint8Array per spec */
  description?: Uint8Array
}

/** Result of isConfigSupported per WebCodecs spec */
export interface VideoDecoderSupport {
  /** Whether the configuration is supported */
  supported: boolean
  /** The configuration that was checked */
  config: VideoDecoderConfig
}

/** Bitrate mode for video encoding (W3C WebCodecs spec) */
export type VideoEncoderBitrateMode = /** Variable bitrate (default) */
'variable'|
/** Constant bitrate */
'constant'|
/** Use quantizer parameter from codec-specific options */
'quantizer';

/**
 * Video encoder configuration (WebCodecs spec)
 * Note: Codec-specific options are encoded in the codec string per W3C spec
 * e.g., "avc1.42001E" encodes profile/level, "vp09.00.10.08" encodes profile/level/depth
 */
export interface VideoEncoderConfig {
  /** Codec string (e.g., "avc1.42001E", "vp8", "vp09.00.10.08", "av01.0.04M.08") */
  codec: string
  /** Coded width in pixels (required) */
  width: number
  /** Coded height in pixels (required) */
  height: number
  /** Display width (optional, defaults to width) */
  displayWidth?: number
  /** Display height (optional, defaults to height) */
  displayHeight?: number
  /** Target bitrate in bits per second */
  bitrate?: number
  /** Framerate (frames per second) */
  framerate?: number
  /** Hardware acceleration preference (W3C spec enum) */
  hardwareAcceleration?: HardwareAcceleration
  /** Latency mode (W3C spec enum) */
  latencyMode?: LatencyMode
  /** Bitrate mode (W3C spec enum) */
  bitrateMode?: VideoEncoderBitrateMode
  /** Alpha handling (W3C spec enum) */
  alpha?: AlphaOption
  /** Scalability mode (SVC) - e.g., "L1T1", "L1T2", "L1T3" */
  scalabilityMode?: string
  /** Content hint for encoder optimization */
  contentHint?: string
}

/** Encode options per WebCodecs spec */
export interface VideoEncoderEncodeOptions {
  /** Force this frame to be a keyframe */
  keyFrame?: boolean
}

/** Result of isConfigSupported per WebCodecs spec */
export interface VideoEncoderSupport {
  /** Whether the configuration is supported */
  supported: boolean
  /** The configuration that was checked */
  config: VideoEncoderConfig
}

/** Options for creating a VideoFrame from buffer data (VideoFrameBufferInit per spec) */
export interface VideoFrameBufferInit {
  /** Pixel format (required) */
  format: VideoPixelFormat
  /** Coded width in pixels (required) */
  codedWidth: number
  /** Coded height in pixels (required) */
  codedHeight: number
  /** Timestamp in microseconds (required) */
  timestamp: number
  /**
   * Duration in microseconds (optional)
   * Note: W3C spec uses unsigned long long, but JS number can represent up to 2^53 safely
   */
  duration?: number
  /** Layout for input planes (optional, default is tightly-packed) */
  layout?: Array<PlaneLayout>
  /** Visible rect within coded size (optional, default is full coded size at 0,0) */
  visibleRect?: DOMRectInit
  /** Rotation in degrees clockwise (0, 90, 180, 270) - default 0 */
  rotation?: number
  /** Horizontal flip - default false */
  flip?: boolean
  /** Display width (defaults to visible width or coded_width) */
  displayWidth?: number
  /** Display height (defaults to visible height or coded_height) */
  displayHeight?: number
  /** Color space parameters (uses init object) */
  colorSpace?: VideoColorSpaceInit
  /** Metadata associated with the frame */
  metadata?: VideoFrameMetadata
  /** ArrayBuffers to transfer (W3C spec - ignored in Node.js, we always copy) */
  transfer?: ArrayBuffer[]
}

/** Options for copyTo operation */
export interface VideoFrameCopyToOptions {
  /** Target pixel format (for format conversion) */
  format?: VideoPixelFormat
  /** Region to copy (not yet implemented) */
  rect?: DOMRectInit
  /** Layout for output planes */
  layout?: Array<PlaneLayout>
}

/** Options for creating a VideoFrame from an image source (VideoFrameInit per spec) */
export interface VideoFrameInit {
  /** Timestamp in microseconds (required per spec when creating from VideoFrame) */
  timestamp?: number
  /** Duration in microseconds (optional) */
  duration?: number
  /** Alpha handling: "keep" (default) or "discard" */
  alpha?: string
  /** Visible rect (optional) */
  visibleRect?: DOMRectInit
  /** Rotation in degrees clockwise (0, 90, 180, 270) - default 0 */
  rotation?: number
  /** Horizontal flip - default false */
  flip?: boolean
  /** Display width (optional) */
  displayWidth?: number
  /** Display height (optional) */
  displayHeight?: number
  /** Metadata associated with the frame */
  metadata?: VideoFrameMetadata
}

/**
 * VideoFrameMetadata - metadata associated with a VideoFrame (W3C spec)
 * Members defined in VideoFrame Metadata Registry - currently empty per spec
 */
export interface VideoFrameMetadata {

}

/** Rectangle for specifying a region */
export interface VideoFrameRect {
  x: number
  y: number
  width: number
  height: number
}

/** Video pixel format (WebCodecs spec) */
export type VideoPixelFormat = /** Planar YUV 4:2:0| 12bpp| (1 Cr & Cb sample per 2x2 Y samples) */
'I420'|
/** Planar YUV 4:2:0| 12bpp| with alpha plane */
'I420A'|
/** Planar YUV 4:2:2| 16bpp */
'I422'|
/** Planar YUV 4:2:2| 16bpp| with alpha plane */
'I422A'|
/** Planar YUV 4:4:4| 24bpp */
'I444'|
/** Planar YUV 4:4:4| 24bpp| with alpha plane */
'I444A'|
/** Planar YUV 4:2:0| 10-bit */
'I420P10'|
/** Planar YUV 4:2:0| 10-bit| with alpha plane */
'I420AP10'|
/** Planar YUV 4:2:2| 10-bit */
'I422P10'|
/** Planar YUV 4:2:2| 10-bit| with alpha plane */
'I422AP10'|
/** Planar YUV 4:4:4| 10-bit */
'I444P10'|
/** Planar YUV 4:4:4| 10-bit| with alpha plane */
'I444AP10'|
/** Planar YUV 4:2:0| 12-bit */
'I420P12'|
/** Planar YUV 4:2:2| 12-bit */
'I422P12'|
/** Planar YUV 4:4:4| 12-bit */
'I444P12'|
/** Semi-planar YUV 4:2:0| 12bpp (Y plane + interleaved UV) */
'NV12'|
/** Semi-planar YUV 4:2:0| 12bpp (Y plane + interleaved VU) - per W3C WebCodecs spec */
'NV21'|
/** RGBA 32bpp */
'RGBA'|
/** RGBX 32bpp (alpha ignored) */
'RGBX'|
/** BGRA 32bpp */
'BGRA'|
/** BGRX 32bpp (alpha ignored) */
'BGRX';
